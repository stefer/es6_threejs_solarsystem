<!DOCTYPE html>
<html>
<head>
    <title>Sun</title>
    <style>
        h1 {text-align: center;}
        canvas {
                width: 100%;
                height: 100%;
                display: block;
        }
    </style>
</head>
<body>
    <canvas id = 'canvas'></canvas>
</body>

<script type="module">

    // Textures from https://www.solarsystemscope.com/textures/
    
    import * as THREE from "./js/three.module.js";
    import { MapControls } from "./js/OrbitControls.js";

    const SizeScale = 5.0
    const au = 149597.870700 // kkm
    const earthEccenticity = 1.718269673643725E-02
    const SunRadiusKkm = 696.0000;
    const SunRadiusKmPerPixel = SunRadiusKkm / window.innerWidth;
    const SunRadius = 0.1;
    const SunScale = 0.1 / SunRadiusKkm; // Units/kkm
    const auUnit = au * SunScale;

    const canvas = document.querySelector('#canvas');
	var renderer	= new THREE.WebGLRenderer({canvas});
    renderer.setSize( canvas.clientWidth, canvas.clientHeight );
    renderer.antialias = true;

	var onRenderFcts= [];
	var scene	= new THREE.Scene();
	var camera	= new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.01, 1000 );
	camera.position.z = 1.5;

    var controls = new MapControls( camera, renderer.domElement );
    //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)
    controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 0;
    controls.maxDistance = 5000;
    controls.maxPolarAngle = Math.PI / 2;

	var light	= new THREE.AmbientLight( 0x888888, 2 )
	scene.add( light )

    var pointLight = new THREE.PointLight( 0xff0000, 1, 100, 2);
    pointLight.position.set( 0, 0, 0 );
    scene.add( pointLight );

    var sphereSize = SunRadius;
    var pointLightHelper = new THREE.PointLightHelper( pointLight, sphereSize );
    scene.add( pointLightHelper );

    var geometry = new THREE.SphereBufferGeometry(SunRadius * SizeScale, 32, 32)
    var material = new THREE.MeshPhongMaterial()
    material.map = THREE.ImageUtils.loadTexture('textures/2k_sun.jpg')
    material.emessive = new THREE.Color( 0xffffff );
    material.emissiveIntensity = 10;
    var sunMesh = new THREE.Mesh(geometry, material)
    scene.add(sunMesh)

    var curve = new THREE.EllipseCurve(
        0,  0,            // ax, aY
        auUnit, auUnit * (1.0 + earthEccenticity),           // xRadius, yRadius
        0,  2 * Math.PI,  // aStartAngle, aEndAngle
        false,            // aClockwise
        0                 // aRotation
    );

    var points = curve.getPoints( 50 );
    var geometry = new THREE.BufferGeometry().setFromPoints( points );

    var material = new THREE.LineBasicMaterial( { color : 0xff0000 } );

    // Create the final object to add to the scene
    var ellipse = new THREE.Line( geometry, material );
    scene.add(ellipse);

    onRenderFcts.push(function(){
		renderer.render( scene, camera );		
	})

	onRenderFcts.push(function(delta, now){
		camera.position.x += (mouse.x - camera.position.x)
		camera.position.y += (mouse.y - camera.position.y)
        camera.lookAt( scene.position )
        camera.zoom = scale;
        camera.updateProjectionMatrix();
	})

    var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		// call each update function
		onRenderFcts.forEach(function(onRenderFct){
			onRenderFct(deltaMsec/1000, nowMsec/1000)
		})
    })
    
</script>

</html>